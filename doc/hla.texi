\input texinfo @c -*-texinfo-*-
@setfilename hla.info
@settitle High Level Applications
@finalout
@c %**end of header

@dircategory Scientific software
@direntry
* hla: (hla).               High Level Applications
@end direntry

@tex
% Mathematical macros taken from the GNU Calc Manual
% ==================================================
%
% Some special kludges to make TeX formatting prettier.
% Because makeinfo.c exists, we can't just define new commands.
% So instead, we take over little-used existing commands.
%
% Redefine @cite{text} to act like $text$ in regular TeX.
% Info will typeset this same as @samp{text}.
\gdef\goodtex{\tex \let\rm\goodrm \let\t\ttfont \turnoffactive}
\gdef\goodrm{\fam0\tenrm}
\gdef\math{\goodtex$\mathxxx}
\gdef\mathxxx#1{#1$\endgroup}
\global\let\oldxrefX=\xrefX
\gdef\xrefX[#1]{\begingroup\let\math=\dfn\oldxrefX[#1]\endgroup}
%
% Redefine @i{text} to be equivalent to @cite{text}, i.e., to use math mode.
% This looks the same in TeX but omits the surrounding ` ' in Info.
%\global\let\i=\cite
%\global\let\math=\cite
%
% Redefine @c{tex-stuff} \n @whatever{info-stuff}.
\gdef\c{\futurelet\next\mycxxx}
\gdef\mycxxx{%
  \ifx\next\bgroup \goodtex\let\next\mycxxy
  \else\ifx\next\mindex \let\next\relax
  \else\ifx\next\kindex \let\next\relax
  \else\ifx\next\starindex \let\next\relax \else \let\next\comment
  \fi\fi\fi\fi \next
}
\gdef\mycxxy#1#2{#1\endgroup\mycxxz}
\gdef\mycxxz#1{}
%
% Define \Hat to take over from \hat as an accent
\gdef\Hat{\mathaccent "705E}
%
%\gdef\beforedisplay{\vskip-10pt}
%\gdef\afterdisplay{\vskip-5pt}
\gdef\beforedisplay{}
\gdef\afterdisplay{}
{\globaldefs = 1
\abovedisplayskip=7pt plus 2pt minus 1pt
\belowdisplayskip=7pt plus 2pt minus 1pt
\abovedisplayshortskip=7pt plus 2pt minus 1pt
\belowdisplayshortskip=7pt plus 2pt minus 1pt}
%\abovedisplayskip=12pt plus 3pt minus 3pt
%\belowdisplayskip=12pt plus 3pt minus 3pt
%\abovedisplayshortskip=7pt plus 1pt minus 1pt
%\belowdisplayshortskip=7pt plus 1pt minus 1pt
%\gdef\beforedisplayh{\vskip-25pt}
%\gdef\afterdisplayh{\vskip-10pt}
%
\gdef\arcsec{\hbox{\rm arcsec}}
\gdef\arccsc{\hbox{\rm arccsc}}
\gdef\arccot{\hbox{\rm arccot}}
\gdef\sech{\hbox{\rm sech}}
\gdef\csch{\hbox{\rm csch}}
\gdef\coth{\hbox{\rm coth}}
\gdef\arcsinh{\hbox{\rm arcsinh}}
\gdef\arccosh{\hbox{\rm arccosh}}
\gdef\arctanh{\hbox{\rm arctanh}}
\gdef\arcsech{\hbox{\rm arcsech}}
\gdef\arccsch{\hbox{\rm arccsch}}
\gdef\arccoth{\hbox{\rm arccoth}}
%
\gdef\Re{\hbox{\rm Re}}
\gdef\Im{\hbox{\rm Im}}
\gdef\Sin{\hbox{\rm Sin}}
\gdef\Cos{\hbox{\rm Cos}}
\gdef\Log{\hbox{\rm Log}}
%
\gdef\erf{\hbox{\rm erf}}
\gdef\erfc{\hbox{\rm erfc}}
\gdef\sinc{\hbox{\rm sinc}}
\gdef\sgn{\hbox{\rm sgn}}
\gdef\sign{\hbox{\rm sign}}
\gdef\det{\hbox{\rm det}}
\gdef\Var{\hbox{\rm Var}}
\gdef\arg{\hbox{\rm arg}} % avoid temporary clobbering of arg in texinfo-4.8
@end tex

@copying

This manual is for tools for accelerator commissioning and physics. It
is original for NSLS-II (National Synchrotron Light Source II)
project, which is under construction at Brookhaven National
Laboratory. 

Copyright @copyright{} 2010 The NSLS-II Project.

@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3 or
@c any later version published by the Free Software Foundation; with the
@c Invariant Sections being "GNU General Public License" and "Free Software
@c Needs Free Documentation", the Front-Cover text being "A GNU Manual",
@c and with the Back-Cover Text being (a) (see below).  A copy of the
@c license is included in the section entitled "GNU Free Documentation
@c License".

@c (a) The Back-Cover Text is: "You have the freedom to copy and modify this
@c GNU Manual."
@end copying

@titlepage
@title High Level Applications
@subtitle Tools for Accelerator Commissioning and Physics

@vskip 5ex
Schedule:
@itemize @bullet
@item 12/01/2011--02/29/2012, LINAC front end commissioning
@item 03/30/2012--07/28/2012, LINAC
@item 05/29/2012--06/28/2012, LBTL
@item 07/28/2012--08/27/2012, LBTL
@item 08/27/2012--12/25/2012, Booster
@item 12/15/2012--01/14/2013, BSTL in Booster
@item 01/14/2013--01/24/2013, BSTL
@item 01/24/2013--09/21/2013, Storage Ring Commissioning Part 1
@item 09/21/2013--11/20/2013, ID installation
@item 11/20/2013--02/18/2014, Storage Ring Commissioning Part 2
@end itemize

@vskip 5ex
@include hlaversion.texi
@author Jinhyuk Choi
@author Guobao Shen (@email{shengb@@bnl.gov})
@author Lingyun Yang (@email{lyyang@@bnl.gov})
@comment @email{tuomo.keskitalo@iki.fi}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents


@node Introduction
@chapter Introduction


This extension package is meant to be a set of applications and client
APIs for accelerator physics study and commissioning. The document is
compiled based on the requirements from the following documents
(@pxref{Reference}):
@itemize @bullet
@item 2008, @cite{NSLS-II: Model Based Control - A Use Case Approach}
@item 2009, @cite{Assumptions on NSLS-II Accelerator Commissioning}
@item 2010, @cite{The Path to Accelerator Commissioning}
@item 2010, @cite{NSLS-II Storage Ring Commissioning}
@end itemize

@node Schedule for Beam Commissioning
@section Schedule for Beam Commissioning

@itemize @bullet
@item 12/01/2011--02/29/2012, LINAC front end commissioning
@item 03/30/2012--07/28/2012, LINAC
@item 05/29/2012--06/28/2012, LBTL
@item 07/28/2012--08/27/2012, LBTL
@item 08/27/2012--12/25/2012, Booster
@item 12/15/2012--01/14/2013, BSTL in Booster
@item 01/14/2013--01/24/2013, BSTL
@item 01/24/2013--09/21/2013, Storage Ring Commissioning Part 1
@item 09/21/2013--11/20/2013, ID installation
@item 11/20/2013--02/18/2014, Storage Ring Commissioning Part 2
@end itemize

@node Terminology for High Level Applications
@section Terminology for High Level Applications

The naming convension and terminology should follow the definitions of
project nomenclature standard (@pxref{Reference}):

@itemize @bullet
@item @cite{National Synchrotron Light Source II - Nomenclature Standard},
@item @cite{National Synchrotron Light Source II - Accelerator Systems
Requirements Document, Storage Ring Physics Nomenclature Standard},
@end itemize

@c @cindex family
A set of commonly used words are explained in the following:

@enumerate
@item @dfn{Mode}
is used for separating different machine settings. There could be
``operational mode'', ``accelerator physics beam study mode'', ``short
bunch mode'', ``low current mode''. With this separation, all the other
settings can be same or different for two modes. 
@item @dfn{Group}
@cindex group
represents a set of elements when they are sharing similar position,
symmetry, purpose, connections or user's preferences. For example, we
can group all sextupoles together with a group name
@code{Sextupole}. From lattice point of view, we can have a group name
@code{QH1} for all quadrupoles with this symmetry. Each element or
magnet can belong to one or more groups.  For consistancy, the element
belongs to the group which has only himself and the group name is same
as its element name (the element name is guaranteed unique).

We can have some predefined group names, and they will be commonly used
for their type or symmetry, e.g. @code{Quadrupole}, @code{SH1}. The
pre-defined group name should be discussed carefully, and stored in a
relational database, IRMIS for example. Users can also define their own
group name which does not overwrite system defined group name.

The suggested candidates of group name are:
@itemize
@item Magnet with same power supply or lattice symmetry. 
@item BPM, Corrector, Quadrupole, Sextupole, SkewQuadrupole
@item BBA, Orbit, Tune, Chromaticity
@item ``Sam's test BPM'', ``Weiming's Toy'', ...
@end itemize

@cindex wildcard
When searching for a group, the name matching should support a subset of
regular expression (need more details on ``subset'', how small/large is
this set). If we are using BASH wildcards:
@itemize
@item @strong{*}, zero or more characters
@item @strong{?}, exactly one character
@item @strong{[abcde]}, exactly one character listed
@item @strong{[a-e]}, exactly one character in the given range
@item @strong{[!abcde]}, any character that is not listed
@item @strong{[!a-e]}, any character that is not in the given range
@item @strong{@{debian,linux@}}, exactly one entire word in the options given
@end itemize

@cindex sequence
@item @dfn{Sequence}
Lingyun suggestes that we can also use sequence to identify one element,
usually BPM or corrector. For the convenience purpose when looping over
BPM or correctors one after the other along the ring, we can use number
as its order, instead of their names. Suggested sequence could be a pair
[@dfn{cell}, @dfn{index}], and @dfn{cell} is the cell number
following the name convention as below, which is an integer between 1
and 30:

@itemize @bullet
@item @cite{National Synchrotron Light Source II - Nomenclature Standard},
@item @cite{National Synchrotron Light Source II - Accelerator Systems
Requirements Document, Storage Ring Physics Nomenclature Standard},
@end itemize

The index is the order (according to s-location) in that cell,
and index starts from 0 to follow some language conversion such as
Python/C/C++.

A definition similar to @code{MML (Matlab Middle Layer)} can be
atopted. This part should be discuss carefully to avoid ambiguity.

@cindex coordinate
@cindex original point
@item @dfn{Coordinate definition},
we always use @code{x}, @code{y} and @code{s} specify the horizontal,
vertical and longitudinal plane. The @math{s=0} (septum or center of
straight ?) point is the injection.
@end enumerate

@node Terminology Definition for Control System
@section Terminology Definition for Control System

@itemize
@enumerate
@item EPICS
@cindex EPICS
@item Channel
@cindex Channel
@item Record
@cindex Record
@item PV (Process Variable)
@cindex PV
@cindex Process Variable
@item CA (Channel Access)
@cindex CA
@cindex Channel Access
@end enumerate
@end itemize

@node Overview of system architecture
@section Overview of system architecture

The high level applications developed by accelerator physicists should
be able to achieve their goals by focusing on algorithms while being
released from tedious data acquisition and manipulation issues. This
is the design strategy for the software architecture. With a clean and
carefully designed interface, collaborators, who have different areas
of expertise such as GUI design, numerical analysis, accelerator
physics, data acquisition, hardware control, and so on, can work
together effectively and productively.

The software framework for commissioning the NSLS-II storage ring beam
adopts a client/server model, and consists of various servers for data
acquisition, communication and management. Based on this structure,
physics applications can be developed to satisfy the requirements of
both day-1 beam commissioning, future beam study, and daily operation.
The system architecture is shown as below:

@center @image{HLA_Architecture, 5.in, 2.94in}
@center @strong{Fig. 1 A client/cerver based architecture for HLA}

Briefly, the system consists of
@itemize @bullet
@item data source layer, which can be low level hardware control
system, or a relational database;
@item a service layer, which provides services to gather data from the
data source layer, and perform data manipulations such as constructing an
orbit using BPM data; 
@item a presentation layer, which present machine status to operators,
and provides an interface for machine control 
@end itemize


@node API Prefix
@section API Prefix

A short summary of API prefix. It serves as guideline but may have
exceptions.
@itemize
@item @strong{meas} is for measurement routines. They may perturb the beam, and affect users.
@item @strong{get} is either read history or the output of online instrument.
@item @strong{set} will change the settings of an online instrument. The value will be gone after next injection(non-topoff)
@item @strong{save} operates on file, read machine to file/DB. (set operates on real machine, on a smaller scale, single element/group). The new value will take effect in next injection/run. 
@item @strong{load} operates on files/DB and set to memory/machine.
@item @strong{calc} is for routines doing calculation and analysis. This is calculation only, does not perturb the beam.
@c @item @strong{anal} is for routines more complicated than @code{calc}, the results are a set of results.
@item @strong{enable/disable} makes element online/offline
@c @item @strong{download/upload} works with remote central managed info, like golden orbit, response matrix. 
@end itemize

There are exceptions that some APIs have prefix not mentioned
above (@pxref{Function Index, Variable Index} for a complete
list).

@node Array Data Arrangement
@section Array Data Arrangement

Whenever the value is an array, sort it in the beam direction, for
example, in increasing order of @math{s} location.


@node Software Requirement
@chapter Software Requirement

This chapter describes software requirement for NSLS-II
commissioning. This list is mainly from @cite{Assumptions on NSLS-II
Accelerator Commissioning} and @cite{NSLS-II Storage Ring
Commissioning}, plus some personal experience.

The items marked with (*) are closely related to HLA (High Level
Applications) development, where we need algorithms instead of straight
display. A more detailed list specfically for accelerator physics
related functions are in next chapter (@pxref{Accelerator Physics
Applications Toolkit})


@node Function List of Control Software
@section Function List of Control Software

@menu
* General Operation::
* Operations Software::
* Major Subsystem::
* Beam Diagnostics::
* Safty Systems::
* Utility Control::
* Accelerator Physics Applications Toolkit::
@end menu

@node General Operation 
@subsection General Operation


@itemize @bullet
@item Overall status page (warning when read/set are different too much ?)
@item Status, Alarm and warning monitor
@item Permit system monitor and control
@item Data logger and data display
@item Electronic logbook
@end itemize

 
@node Operations Software
@subsection Operations Software

@itemize @bullet
@item Accelerator parameter store/restore (*)
      @enumerate
      @item With file-manager, editing capability
      @item smoothly ramp from one stage to another.
      @item (compare two stages)
      @end enumerate
@item Injection Control
@item Power supply control
@item RF control
@item Fast orbit feedback control
@item Front-end monitoring and control
@item Machine protection system display and control
@item Magnet temperature interlock display and control
@item Scraper and movable mask operations
@end itemize


@node Major Subsystem Control
@subsection Major Subsystem Control

@itemize @bullet
@item Power supply page which lists for all PS:
      @enumerate
      @item setting or waveform, read back
      @item difference between DCCTs, status
      @item recent history.
      @end enumerate
@item RF page with all relevant settings, read back, status, parameters
@item Vacuum display and control
@item Cryogenics system display and control
@item Pulsed magnet systems monitor and control
@end itemize


@node Beam Diagnostics
@subsection Beam Diagnostics

@itemize @bullet
@item Beam orbit page with closed orbit, turn by turn, single turn, status information, difference (referecne orbit display) (*)
@item Beam current history and lifetime display (*)
@item Bunch intensity display and history display/analysis (*)
@item Beam emittance display (*)
@item Injection element display and control page (*)
@item Timing system display and control 
@item Synchronization system display and control
@item Tune display and control (*)
@item Temperature monitoring display
@end itemize

@node Safety Systems
@subsection Safety Systems

@itemize @bullet
@item Personal protection system status display
@item Equipment protection status display and control
@item Beam containment status display and control
@item Top-off status monitor
@end itemize

@node Utility Control
@subsection Utility Control

@itemize @bullet
@item Tunnel air temperature and humidity monitor
@item Mechanical utilities status and controls
@item Electrical utilities status and controls
@item Equipment enclosure monitor
@item Water colling system display
@item Controls network monitor
@end itemize

@node User Preferences
@section User Preferences

It is better that the HLA can have the following features:

@enumerate 
@item Interactive control.
@item Fast script prototyping.
@item Full set of mathematical functions. e.g. FFT, polynomial fitting, statistics, histogram.
@item Visualization.
@item GUI ability.
@item Online modification: in control room within a shift, want to change code temporary to fullfil a job on time.
@end enumerate 



@c -------------------------------------------------------------


@node Accelerator Physics Applications Toolkit
@chapter Accelerator Physics Applications Toolkit

This chapter is a more detailed list of control software for NSLS-II
commissioning. The functions here contain more accelerator physics
concepts, beam control and manipulation. For the specification of
these tools, @pxref{Specification for Accelerator Physics Toolkit}


@node Requirement
@section Requirement

We have compiled a set of requirements for high level control software,
and design the APIs as a common library. The high level applications
will use these APIs to fulfil comissioning, operations and physics
studies. We need more input from operation group to make these tools more operator-friendly.

@node Physics Tasks for Storage Ring
@subsection Physics Tasks for Storage Ring


In @cite{NSLS-II Storage Ring Commissioning} (@pxref{Reference}), we have defined steps for
commissioning. Here we only summarize the functions needed, and neglect
the order of using them in the commissioning.

@itemize @bullet
@item Hardware/Control checking and testing
      @itemize @minus
      @item BPM testing programs: stability, polarity, current dependency, resolution.
      @item Orbit corrector test, polarity, strength.
      @item Set/Read any main magnet. Converting between machine unit and physics unit.
      @item Ramping from one magnet setting to another.
      @item Monitoring stability of any readings and online data: magnet readback, orbit, temperature, vacuum.
      @item Magnetic field measurement and modeling, determine calibration
      @item Verify named devices in control system, control proper hardware
      @item Check polarity of all magnets.
      @item Complete survey of magnetic elements
      @item Test diagnostic equipment without beam
      @end itemize
@item BTS transport line, obtain good transmission through septum and good transverse phase space match, set timing of pulsed magnets.
@item Linear and nonlinear lattice modeling
      @itemize @minus
      @item First turn beam steering. Turn by turn BPM data visulization and analysis
      @item Obtain first turn in storage ring using single kicker
        @itemize @minus
        @item Center beam in single downstream single kicker
        @item Adjust kicker strength to place beam on design orbit.
        @item Use single turn BPMs to steer beam trajectory around ring and estimate linear optics and tune.
        @item Use flag to obtain beam size information at injection point and after one turn.
        @end itemize
      @item Single shot beam position, turn by turn BPM reading and orbit analysis.
      @item Measure the orbit response matrix, with flexible number of BPMs and correctors.
      @item Static orbit correction with flexible list of correctors and BPMs.
      @item Local closed orbit bump (one page, particularly for injection).
      @item Measure and adjust tune. (tune scan ?)
      @item Measure and correct the chromaticity (linear and nonlinear). 
      @item Measure beam optics including phase advance, beta functions, dispersion.
      @item Dispersion measurement and correction
      @item Beam based alignment (quadrupole and BPM).
      @item Beam based alignment of sextupoles.
      @item Linear optics fitting and optimization with LOCO.
      @item Develop lattice model using measured fields, linear/nonlinear optics.
      @item Reduce beta beat
      @item Correct coupling using skew quadrupoles
      @item Analysis on nonlinear dynamics.
      @item Use Pinger to measure tune shift with amplitude, dynamic aperture and characterize sextupole distribution
      @item Wakefield modeling and tracking studies, develop model for impedance and wakefields, caculation and measurement, estimate instability thresholds, simulate bunch-by-bunch feedback with realistic bunches and wakefields.
      @item Characterize ring impedance using beam.
      @end itemize
@item Logging all necessary machine settings data, and retrive the historical data for analysis.
@item Look for magnet errors that may have been missed in testing.
@item Commission loss control minitoring system
@item Use visible synchrotron light monitor to study transverse beam profile and disturbance due to kickers. @code{getBeamProfile}
@item Study lifetime versus vacuum pressure, vertical beam size, scraper, dynamic aperture.
@item Test fast orbit feedback system.
@item Commission transverse bunch-by-bunch feedback
@item Measure variation of coherent tune with current
@item Study increasing chromaticity from +2/+2 to +5/+5
@item Commission undulator gap control in control room
@item Establish and save reference orbit (low current 5mA)
@item Calibration/Testing of Equipment Protection Interlock System
  @itemize @minus
  @item Center photon beam in exit slot
  @item Verify gap open/close status is properly reported to interlock system
  @item Measure interlock BPM offset and scale factors.
  @item Adjust the hardware trip points on the local logic chassis
  @item Verify beam is dumped at the specified position offsets.
  @item Set the values in the interlock test file
  @item Set the values in the micro
  @item Verify the proper operation of the interlock test
  @end itemize
@item ID
  @itemize @minus
  @item When necessary compensate the linear optics for ID
  @item Observe orbit and tune shift vs gap
  @item Measure lifetime vs gap
  @item Observe beam stability vs current
  @item Measure change in impedance due to ID chamber
  @item Prepare look-up tables for feed forward orbit correction coils.
  @item Measure effect on tune shift with amplitude, chromaticity, and emittance coupling.
  @item Measure impedance vs gap for IVUs
  @item Commission undulator gap control for users
  @item Measure flux and brightness
  @end itemize
@item Top-off Injection
  @itemize @minus 
  @item Check position of apertures in ring and beamline
  @item Test interlocks
  @item Characterize injection transient on transverse orbit, contribution from septum and kickers.
  @item Test transverse feedback with injection transient
  @end itemize
@item Concerns: accuracy of magnet calibration-two types of dipoles, magnetic field quality (IRMIS data).
@end itemize


@node Physics Tasks for Injector
@subsection Physics Tasks for Injector

Software routines needed for the injector commissioning and operation
are listed in this section. Some of these routines will be delivered
by linac and booster vendors, others have to be developed by ourselves.

@itemize

@item Linac
@itemize
@item Diagnostics calibration       
@item Routines for optimization of linac performance 
@item Energy feedback
@item Charge feedback
@item Specification of bunch train format    
@item Beam loading compensation      
@item Energy measurement     
@item Energy spread measurement      
@item Emittance measurement (3 screens)      
@item Emittance measurement (quad scans)     
@item Matching of Twiss parameters into booster septum       
@item Beam stacking  
@item Beam transmission optimization 
@item TL quad centering      
@item Integration of safety devices/interlocks       
@end itemize

@item Booster
@itemize
@item Diagnostics calibration       
@item Orbit correction       
@item Tune measurement system
@item Energy measurement     
@item Momentum compaction measurement
@item Emittance measurements 
@item Beam stacking  
@item Extraction optimization
@item Ramp optimization      
@item LOCO-type machine characterization     
@item MIA in transport line -- booster acceptance testing    
@item Orbit feedback 
@item Synchrotron Radiation diagnostics      
@item Bunch cleaning system  
@item TL quad centering      
@item Integration of safety devices/interlocks       
@end itemize 
@item SR


In addition to what has been already specified by Accelerator Physics:

@itemize
@item Closed bump optimization: A and t     
@item Simultaneous measurements of injected/stored beam orbits       
@item Measurement of injection efficiency
@end itemize

@end itemize

@node HLA Scripts and Applications
@section HLA Scripts and Applications

Here are several applications for machine commissioning and accelerator
physics study. 

One interactive @code{Python} environment is also provided for
interactive control of the storage ring. In this interactive
environment, a set of APIs are provided to make physicists who has no
knowledge of EPICS or low level channel access be able to do many
measurements and diagnostics.

This interactive mode can also run as batch mode, which makes the
prototyping of new HLA and algorithms more easier.

The plotting features are only in interactive environment and GUI
applications.

The HLA and Controls are divided into three layers: HLA applictions and
scripts, client API (@pxref{Client APIs (CAPI)}) and server API
(@pxref{Server APIs (SAPI)}).

@itemize 
@item BBA and LOCO are HLA applications. Turn by turn beam orbit measurement and analysis can be a HLA script.
@item Client APIs are a group of physics logics, e.g. @code{measOrbitRm}, @code{measChromaticity}, @code{getGoldenOrbit}, ...
@item Server APIs are called by client APIs across the network, and will not be seen by HLA applications or scripts. The server APIs have two major functions:
      @itemize @minus
      @item manage the accelerator magnets/lattice information, e.g. logic group of a magnet, whether it is used by BBA or LOCO or orbit measurement etc. The basic information is contained in a XML file or a database in the following sections, (the implementation may not be a XML file, but a Database).
      @item control the magnets via a control server, this server will call low level APIs to do PV readings and settings.
      @end itemize
@end itemize


@node Machine Status
@subsection Machine Status

The applications will provide overall status of the whole machine, and give
warnings when any abnormal beam behaviour is detected, for example a
readback differs from setting point larger than its threshhold. The
status includes beam information, and hardware status including magnet
and its power supply, vacuum, RF, and so on.

@itemize @bullet
@item Orbit, plots, numbers, status.
    @enumerate
    @item Closed orbit display
    @item Orbit feedback status
    @item Orbit stability, especially drift and variation
    @item Turn by turn BPM reading vistualization when available/enabled
    @end enumerate
@item Tunes, numbers
@item Magnets, tables of data
@item Vacuum status, plots, tables.
@item Logging all necessary machine settings data, and retrive the historical data for analysis.
@end itemize


@node Orbit Display and Correction
@subsection Orbit Display and Correction
@c item Orbit Display and Correction
   
@itemize @minus
@item plot static orbit. (with magnet layout)
@item plot single shot orbit
@item correct static orbit. (selective correctors and BPMs)
@item absolute orbit offset and orbit offset with respect to golden orbit
@item plot orbit change from now on.
@item orbit statistics.
@item select BPMs for plotting/orbit correction.
@item select correctors for orbit correction.
@item set reference for orbit reading.
@item get/plot turn-by-turn BPM signal, including orbit and sub/diff
@end itemize


@node Beam Based Alignment (BBA)
@subsection Beam Based Alignment (BBA)

BBA use a list of correctors, BPMs and nearby quadrupoles, to steer the
beam through center of these quadrupoles. The input is a list of
corrector-BPM-quadrupole triplets.  The BPMs in corrector-BPM-quadrupole
triplet is a subset of live BPM.  This needs to get the golden orbit,
set the golden orbit, line fitting, step the quadrupole, step the
corrector (this can be a ``macro step'', e.g. 10 times than normal step
size). Many raw data needs to be saved in certain format (@strong{DISCUSSION}:
plain text, C binary, HDF5, SDDS, Matlab ?).

We would prefer to have all data saved, corrector settings/readings, BPM
readings and Quadrupole settings/readings.

The measurement and analysis can be separated conceptually, which makes the
post processing more easier, i.e. we can analyze any historical data. 

It should work on separate set of quadrupoles, and combine data with previous measurement.

@node Linear Lattice Fitting (LOCO)
@subsection Linear Lattice Fitting (LOCO)

@itemize @minus
@item analyze quadrupole gradient error.
@item analyze BPM gain error.
@end itemize

It requires:
@enumerate
@item Designed orbit response matrix (ROM)
@item change specified correctors 
@item get closed orbit change at specified BPM
@end enumerate

This application needs mathematical package to do minimization and
singular value decomposition (SVD). It also requires simulator for
fitting.

@node Measure TWISS Parameters
@subsection Measure TWISS Parameters

@itemize @minus
@item measure beta functions
@item measure dispersion
@item measure chromaticity
@item measure coupling
@item measure coupling response matrix
@end itemize

@node Smooth Ramping
@subsection Smooth Ramping

@itemize @minus
@item list channels we are interested.
@item ramp whole group at certain rate.
@end itemize
It requires:
@enumerate
@item searching for channels (regular expression, wild-card)
@item save state/read stage.
@end enumerate
The control group may provide ramping for whole storage ring, here this
application can ramp specified channels between two states.

@node History Analyzer
@subsection History Analyzer

@itemize @minus
@item view archive data in certain time frame.
@item link to logbook to view reasons for shutdown, current drop (?)
@item simple statistic for the data: average, variance, maximum, minimum.
@item print, save figures.
@end itemize


@node Insertion Device Related (Matching)
@subsection Insertion Device Related (Matching)

@itemize @minus
@item get/correct closed orbit distortion
@item get/correct phase distortion
@item get/correct coupling distortion
@end itemize

@node Simulator
@subsection Simulator

This is usefull for LOCO lattice fitting. If we decide to have it, an
independent set of APIs could be a choice. This is easier if the
simulator has a simple form instead of complete mimic of a real machine.

@node Misc
@subsection Misc

@itemize  @minus
@item RF feedback. Choi proposed a RF feedback application, which detects orbit drift and change RF frequency.
@item Current dependency of BPM and orbit feedback. Choi proposed to measure the current dependency of BPM readings and compensate that for orbit feedback.
@item PBPM matching. Choi proposed to read both BPM and PBPM, and use BPM to predict the PBPM values, since he thought PBPM reading can be affected by local status including Front End.
@item get groud motion and chamber motion if there are available readings (Choi proposed)
@item monitor loss. Get loss monitor readings from beam containment system (beam loss monitor).
@item Identify MPS (magnet power sypply) ripples.
@item Magenet reproducibility. Choi proposed that test magnet setting reproducibility by setting same values for several times and check the variance/average of its result, which could be orbit shift, tune change, etc. Check and confirm that the hystereses of correctors do not affect the orbit stability. Also identify the correctors with excessive hystereses if there are any.
@end itemize
@c @end enumerate



@node Specification for Accelerator Physics Toolkit
@chapter Specification for Accelerator Physics Toolkit

@node Orbit
@section Orbit

@itemize @bullet
    @item Orbit
    @enumerate
    @item Closed orbit display

        Description: 
        
        Repetition rate: .5Hz
        
        Related APIs: @code{getOrbit}, @code{getLocation}
        
        Data structure: One dimension array, time stamp, BPM status
        (Bad or Good), severity.

        Other requirement: Bad BPM identification should be done in
        other application. Data synchronization to be done in low
        level server part.

    @item Orbit feedback status

        Description: 
        
        Repetition rate: .1Hz
        
        Related APIs: @code{getFofbStatus}
        
        Data structure: On/Off status only? To be defined.

        Other requirement: @strong{TBD}. Historic plotting can be done using
        strip tool or CSS (Control System Studio).

    @item Orbit stability, especially drift and variation

        Repetition rate: 
        
        Related APIs: 
        
        Data structure:

        Other requirement:

    @item Turn by turn BPM reading vistualization if available

        Description: 
        
        Repetition rate: .01Hz
        
        Related APIs: @code{getTbtBpmBuffer}
        
        Data structure: One dimension array, time stamp, severity.

        Other requirement: @strong{TBD}. 

    @end enumerate

    @item Tunes

        Description: 
        
        Repetition rate: 1Hz
        
        Related APIs: @code{getTune}
        
        Data structure: [tune_x, tune_y], time stamp, severity.

        Other requirement: @strong{TBD}. Hostoric plotting can be done using
        strip tool or CSS (Control System Studio).

    @item Magnets

    Description: The status presents all status, such as ON/OFF, set
                 point, read back, temperature and so on. This is for
                 all magnets and their power supply including main
                 dipole, quadrupole, sextupole, correctors. Gives
                 warnings when they differs more than threshold, or the
                 settings is outside of specified range.

    Repetition rate: 
        
    Related APIs: 
  
    Data structure: 

    Other requirement: @strong{TBD}. 

    @item Vacuum status.

    Description: The status presents all status, such as Online/Offline, set
                 point, read back, temperature, pressure and so on for
                 all vaccum devices. Gives warnings for example when
                 vacuum pressure is over threshold. 

    Repetition rate: 
        
    Related APIs: 
  
    Data structure: 

    Other requirement: @strong{TBD}. 

@end itemize


@node Client APIs (CAPI)
@chapter Client APIs (CAPI)

This section describes the high level API which is used in the HLAs,
scripts and the interactive environment.

The client APIs are a set of high level functions with physics
meanings. It hides the low level function calls from its users, who are
mainly accelerator physicists, operators and high level GUI application
developers. It is not required for a user of CAPI to have any
knowledge of EPICS system such as channel access and/or pv name. A
user can get all desired data with hardware name (magnets for
example), location, group, .... 

The internals of CAPI needs a configure file which links abstract
hardware name, their location or any abstract symbol representing them
to real EPICS channels.

Roughly speaking, CAPI is a subset of Matlab Middle Layer, while High
Level Applications/Scripts (HLA) are not.

The API name follows the convention as described (@pxref{API
Prefix}). Addtion to that, some commonly used abbreviation is treated as
one word, only the first letter is in upper case. e.g. @strong{Bpm}
(beam position monitor), @strong{Rm} (response matrix), @strong{Sp}
(setpoint), @strong{Rb} (readback), @strong{Rf} (radio frequency),
@strong{Fofb} (fast orbit feedback), @strong{Sofb} (slow orbit
feedback).

The error processing of these APIs are in defined global constant or in
forms of exception, instead of meaningless integer numbers.
integer. Some error codes are proposed as below:
@itemize @bullet
@item @math{0}: successful
@item @math{1}: fault
@item @math{2}: object, group for example, is not empty
@item @math{3}: object, element/group name for example, does not exist
@item @math{4}: object, element/group for example, already exist
@end itemize

The GUI part will not be included here. But Lingyun suggested that
@code{PyQt} is a good candidate for Python. It is easier to use and full of features.

Here is a demo of how a short script looks like:

@example
#!/usr/bin/env python
import capi as sr
import numpy as np
import time
# returns all channels belongs to group "CELL30" and "BPMx"
bpms1 = sr.getMembers(group="CELL30", group="BPMx")
# get orbit at cell 30
orbit1 = sr.getOrbit(bpms1)
orbit_sq2 = np.sum(orbit1*orbit1)
time.sleep(2)
# exactly same as before, get all BPMs in cell 30
bpms2 = sr.getMembers(group="P*C30*", group="BPMx")
orbit2 = sr.getOrbit(bpms2)
orbit_sq2 = np.sum(orbit2*orbit2)
orbit_diff = np.zeros(len(orbit2), 'd')
for i,bpm in enumerate(bpms2):
    orbit_diff[i] = orbit2[i] - orbit1[bpms1.index(bpm)]
@end example

These APIs are available in interactive environment in a slight different
form due to different language binding, e.g. getOrbit in interactive
environment may looks like ::

@example
#!/usr/bin/env python
import matplotlib.pylab as plt
import capi as sr
# get orbit at PH1G2C30A, PM1G4C30A (index starts at 0)
orbit = sr.getOrbit(sequence=[[0,0], [0,2]])
plt.plot(bpmlocation, orbit[:,0], '-o', label=''H'')
plt.plot(bpmlocation, orbit[:,1], '-x', label=''V'')
@end example

While in a C/C++ bindings (typically in a matured HLA, who evolved from a
script to a standalone stable application) look like the following

@example
#include ``capi.h''
int main(int argc, char* argv[])
@{
    getOrbit(x, y, bpmlist);
    getOrbit(x, y, "PM[1-2]*C20*");
@}
@end example

It is not clear yet, whether or when do we need the C/C++ bindings. In
the first days of commissioning, Python scripts and applications are
able to fulfil all tasks.

@node Data Management
@section Data Management

There are many global configurations and data need to be organized, and
a centralized way is preferred. Update one should be visiable to other
applications if those applications are in same framework as HLA.

Operators or accelerator physicists can have their own directory for
storing data, and it is separated from machine setup or different modes.
They can also have their own scripts, but we suggest them use a code
repository as we are using for better version tracking, compatability
and backup.

The data required for machine operation needs to be in centralized
space, while user data/plots can be on a file system in their own
directory. The data HLA relies on and controls are:

@enumerate
@item Operation mode. 

One mode is like one brand new storage ring. The mode returns only
properties like mode name, description, and so on. Associated machine
configuration, magnet power supply setting for example is stored
separatedly, and can be retrieved using the mode name. The data
structure is as below:

    @enumerate
    @item @emph{mode name},

    The mode name is treated as a string, such as "simulator", "operation", "AccPhys1", "low alpha", "low beta"

    @item @emph{description},

    Any description is added here when this mode is created, and/or
    modified.

    Date format: Simple string, approximately with the size of one paragraph.

    @item @emph{create date},

    This identifies the first time that this mode is created.

    Date format: ISO 8601 format, ``YYYY-MM-DDTHH:MM:SS.mmmmmm'', e.g. '2002-12-25T00:00:00' or '2002-12-25 00:00:00', need discussion on @strong{UTC} or @strong{local} time with daylight saving ?

    @item @emph{modified date},

    This identifies the last date that this mode is modified.

    Date format: ISO 8601

    @item @emph{creator}. 

    This identifies who creates this model.

    @end enumerate 

    Related APIs: @code{getCurrentMode}, @code{getModeInfo}, @code{getAllModes}.

    A version tracked storage is preferred (e.g. In database, or in file system with different directory).

@item Lattice organization:

    The bare lattice can be saved and restored with this information.

    @enumerate
    @item @emph{element full name} 

    The element physics name, which follows the NSLS-II nomenclature
    standard, and each name is unique.

    @item @emph{element type}

    This information is used to define a 

    @itemize @bullet
    @item MARKER, a marker  
    @item DRIFT, drift space
    @item DIPOLE, main dipole
    @item QUADRUPOLE, quadrupole
    @item SEXTUPOLE, sextupole
    @item CORRECTOR, corrector.
    @item BPM, beam position monitor
    @item RF, radio frequency
    @end itemize

    @item @emph{element s-location}

    The element position along @emph{s} direction. The value depends
    on the coordinate definition. Should it be unique?

    Unit: [meter]

    @item @emph{element length}

    The element length.

    Unit: [meter]

    @item @emph{K1 value}

    The default K1 value. Typically, this is for bare lattice.

    Unit: [1/meter^2]

    @item @emph{K2 value}

    The default K2 value. Typically, this is for bare lattice.

    Unit: [1/meter^3]


    @item @emph{angle}

    The default bending angle. Typically, this is for main dipole. The
    bending angle should be zero for other type magnet.

    Unit: [rad]

    @item @emph{...}

    Other information to be added here.

    Unit: [a.u.]

    @end enumerate

    Related APIs: @code{getBareLattice} @code{saveBareLattice}

@item Machine configuration:

    @enumerate
    @item @emph{element groups}

    multiple string, can be added by users. For export to elegant,
    need a group name for its type like "Quadrupole", "Sextupole",
    "RF"

    Default groups for each subsystems:
    @itemize @bullet
    @item Magnet
    @itemize @bullet
    @item Groups from its type: @emph{Dipole}, @emph{Quadrupole}, @emph{Sextupole}, @emph{Corrector}, (also @emph{HCorrector} or/and @emph{VCorrector} if it has x/y direction), @emph{Bpm}, @emph{SkewQuadrupole}
    @item Groups from its symmetry: @emph{Cell01A}, @emph{Cell01}, @emph{Cell01B}, ..., @emph{Girder2}, @emph{Girder4}, ...
    @end itemize
    @item Power Supply
    @item Diagnostic
    @itemize @bullet
    @item BPMx
    @item BPMy
    @item ...
    @end itemize
    @item Vaccum
    @item RF (Radio Frequency)
    @item PPS (Personal Protection System)
    @item EPS (Equipment Protection System)
    @item ...
    @end itemize
      
    @item @emph{setting/reading channels}

    readback/setpoint, may have more channels associated with one magnet/element
      
    @item @emph{setting/reading channel limits}

    lower and upper bound
      
    @item @emph{channel set/read unit}, unit for each channel
      
    @item @emph{channel label}, when plotting, default label
      
    @item @emph{online(enabled)/offline(disabled) status}
      
    @item @emph{cell number, girder number}
      
    @item @emph{bpm sequence number}

    @item @emph{alignment error}
    @itemize @bullet
    @item dx. alignment error at @emph{x} direction
    @item dy. alignment error at @emph{y} direction
    @item ds. alignment error at @emph{s} direction
    @c @item pitch. alignment error at @emph{???} direction
    @c @item yaw. alignment error at @emph{???} direction
    @item roll. alignment error at @emph{???} direction
    @end itemize

    @end enumerate

The configure file may look like the following ::

@example
  <?xml version="1.0" encoding="UTF-8">
  <lattice name="NSLS-II" mode=''nominal''>
      <element>
          <name link="Ha">CH1YSP01</name>
          <cell>1</cell>
          <girder>2</girder>
          <group>Corrector</group>
          <group>VCorrector</group>
          <group>BeamBasedAlignment</group>
          <setpoint>0.0</setpoint>
          <pv name="SR:C01-MG:G03A.SP">HKICK</pv>
          <location>3.5</location>
      </element>
      <element> ... </element>
   </lattice>
   <lattice name=''booster'' mode=''default>
   </lattice>
@end example

This is a horizontal orbit corrector @code{CH1YSP01}, it belongs to @code{section 1},
@code{girder 2}, together with other elements, it is in two groups called
@code{Corrector} and @code{HCorrector}, it is also linked to a power supply @code{Ha},
to which other horizontal corrector may belongs. The group name
@code{BeamBasedAlignment} also implies that this corrector will be used for
beam based alignment.

More information can be added to this configure file. 

     @itemize
     @item Orbit correction ?
     @item Tune correction ?
     @item Chromaticity correction ?
     @end itemize

This file is needed by HLAs, and easily ported to other storage
rings. We can provide a local copy of this file or access it from
network (API or network file system).

Related APIs: @code{getGroups}, @code{getLocation},
@code{getAllGroups}, @code{getNeighbors}, @code{getDevice},
@code{getAlignment}, @code{getChannel}, @code{getStatus}

@item Golden orbit

Include phase advance, beta function, dispersion and 
chromaticity. All are for both horizontal and vertical planes.
      @enumerate 
      @item @emph{golden orbit}, BPM name, orbit value, unit and timestamp
      @item @emph{phase/phase advance}, BPM name, phase value, and timestamp
      @item @emph{beta function}, BPM name, beta value, and timestamp
      @item @emph{dispersion}, BPM name, dispersion, andtimestamp
      @item @emph{chromaticity}, BPM name, chromaticity, and timestamp
      @end enumerate
Related APIs: @code{getGoldenOrbit}, @code{setGoldenOrbit}, @code{saveGoldenOrbit}, @code{loadGoldenOrbit}.

Better to have these data versioned (keep track of data change, either
in the database way or in file system)
@item Orbit response matrix:

Include tune, chromaticity, RF phase and voltage. All are for both horizontal and vertical planes.
      @enumerate 
      @item @emph{orbit response matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{correctors}, a list of element names
      @item @emph{bpms}, a list of element names
      @item @emph{tunes}, value
      @item @emph{chromaticity},
      @item @emph{RF voltage}, 
      @item @emph{RF phase}, 
      @item @emph{corrector name/strength pair}
      @item @emph{closed orbit shift}, for each corrector setting, we have one set of closed orbit
      @end enumerate
Related APIs: @code{getOrbitRm}, @code{saveOrbitRm}

@item Tune correction matrix:

Include quadrupole setting. All are for both horizontal and vertical planes.
      @enumerate
      @item @emph{tune RM matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{quadrupole used}
      @item @emph{quadrupole values}
      @item @emph{tune values}
      @end enumerate
Related APIs: @code{getTuneRm}, @code{saveTuneRm}

@item Chromaticity correction matrix:
      @enumerate
      @item @emph{chromaticity RM matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{sextupole used}
      @item @emph{sextupole values}
      @item @emph{tune values}
      @item @emph{fitted polynomial coeffients}, 5 values ?
      @item @emph{RF voltage}
      @end enumerate
Related APIs: @code{getChromRm}, @code{saveChromRm}

@item Unit conversion

These data are associated with each magnet.
      @enumerate
      @item @emph{unit convertion table}, a table convert engineer(current, voltage) number to physics (mm, rad) number
      @item Sextupole/Quadrupole K-value vs. current
      @item Corrector current vs. angle/orbit shift
      @end enumerate

Related APIs: @code{TBD}

@item Step size for magnet ramping/scan, (already in lattice ? or define independently)
    @enumerate
    @item @emph{step size}, a sigle number when user want to step a channel, to see small effects. e.g. small kick of beam to see the orbit change. 
    @end enumerate
Related APIs: @code{getStepsize}, @code{stepUp}, @code{stepDown}
@end enumerate


@node Data Management API
@section Data Management API

@table @code

@deftypefun {mode =} getCurrentMode () 
Get current operation mode with @code{getCurrentMode}.

Data structure:
@enumerate
@item params: None
@item return: Current machine operation mode(@pxref{Data Management}: Operation mode)
@end enumerate

@deftypefunx {[modes] =} getAllModes()
Get all operation modes with @code{getAllModes()}. 

Data structure:
@enumerate
@item params: None
@item return: An array of operation mode. Each mode as (@pxref{Data Management}: Operation mode)
@end enumerate

The operation mode is used to group different response matrix, tunes,
beta and ramping for different storage ring settings. One mode can be
norminal operation mode, the others can be accelerator physics mode,
single bunch mode, different working point(tunes), low alpha mode,
low beta mode, high beta mode, ... 

@end deftypefun

@deftypefun {status =} addGroup ( @var{group} )
Add and create a new group with given group name with @code{addGroup()}. 

Data structure:
@enumerate
@item params: group - string; new group name 
@item return: status
@end enumerate

@deftypefunx {status =} removeGroup ( @var{group} )
Delete an existing group with given group name with @code{removeGroup()}. 

Data structure:
@enumerate
@item params: group - string; group name to be deleted
@item return: status
@end enumerate

@deftypefunx {status =} addGroupMember ( @var{group}, @var{members} )
Add members to an existing group with @code{addGroupMembers()}. 
If a member exists in this group, update it.

Data structure:
@enumerate
@item params: group - string; group name to add members to.
@item params: members - string array; member list to be added
Definition of members @strong{TBD}. Could be channel name, or magnet
physics name.
@item return: status
@end enumerate

@deftypefunx {status =} removeGroupMember ( @var{group}, @var{members} )
Remove member(s) from specified group @code{removeGroupMember()}. 

Data structure:
@enumerate
@item params: group - string; group name to be deleted
@item params: members - string array; member list to be deleted
@item return: status
@end enumerate

They operate on group/member management. These @var{members} support
wildcards. @code{removeGroup} should clean up the relations of members
to this group (may call @var{removeGroupMember}) or @strong{remove a
nonempty group is forbiden}, like @code{rmdir} in Linux.

All operation modes share same group settings. We can use a new group
name for various mode. e.g. If some correctors only works in ``physics''
mode, we can have a group name for them.

@strong{WARNING}: for some group, it would be nice to be readonly, too
dangerous to change in script.
@end deftypefun

@deftypefun {[groups] =} getGroups ( @var{element} )
Get group(s) that given element name belongs to with @code{getGroups()}. 

Data structure:
@enumerate
@item params: element - string; Element name.
@item return: group(s) - string array. Empty if element does not
either belong to any group nor exist.
@end enumerate

@c @deftypefunx {info=} getGroupInfo ( @var{group} )

@deftypefunx {[members] =} getMembers ( @var{group} )
Get members(s) that belongs to certain group with @code{getMembers()}. 

Data structure:
@enumerate
@item params: group - string; Group name.
@item return: member(s) - string array. Empty if group does not
either have any member nor exist.
@end enumerate

@deftypefunx {[groups] =} getAllGroups ( )
Get all group name(s) with @code{getAllGroups()}. 

@strong{To be discussed}. What is this for? How this should be processed?

Data structure:
@enumerate
@item params: None.
@item return: group(s) - string array. Empty if there is no group defined.
@end enumerate

@code{getGroups} returns group name list to which a specific element
belongs.  The element name should be uniqe in lattice. @code{getMembers}
returns all elements in a group or groups. The order of @var{members}
does matter, must be in increasing order of
@math{s}. @code{getAllGroups} returns all groups available in the
system. 

@c @code{getGroupInfo} returns the information of this single group (no wildcard/regular expression matching).
@end deftypefun

@deftypefun {[s] =} getLocation ( @var{group} )
Get @math{s} location of all element belongs to certain @var{group}, the order matters.

Data structure:
@enumerate
@item params: group - string; Group name.
@item return: s - numeric (double) array. Empty if group does not
either have any member nor exist.
@item unit: [meter].
@end enumerate

@end deftypefun

@deftypefun {[phase] =} getPhase ( @var{mode}, @var{group}, @var{plane} )
Get phase advance at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: phase - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [rad].
@end enumerate

@deftypefunx {[beta] =} getBeta ( @var{mode}, @var{group}, @var{plane} )

Get beta at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: beta - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [meter].
@end enumerate

@deftypefunx {[eta] =} getDisp ( @var{mode}, @var{group}, @var{plane} )

Get dispersion at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: eta - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [TBD].
@end enumerate

@deftypefunx {[@var{chromx}, @var{chromy}] =} getChrom ( @var{mode} )

Get chromaticity at certain mode.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: [hori, vert] - numeric (double) array. Empty if mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [TBD].
@end enumerate

@deftypefunx {(@var{nux}, @var{nuy}) =} getTune ( @var{mode} )

Get tune at certain mode.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: [nux, nuy] - numeric (double) array. Empty if mode does not exist.
Simulation value if the mode is "simulator", otherwise, measured value.
@item unit: [TBD].
@end enumerate

@deftypefunx {(@var{nux}, @var{nuy}) =} getTune ( )

Get measured tune in real time.

Data structure:
@enumerate
@item params: None.
@item return: [nux, nuy] - numeric (double) array. Empty if failed.
@item unit: [TBD].
@end enumerate

All @code{get*} functions are just readout, i.e. a stored value, not
real time measurement, for example @code{getChrom}, which
returns the horizontal and vertical chromaticity. The chromaticity
value should be saved together with the @var{mode} of current lattice:
"operation", "AP mode 1", "AP mode 2". They need to access the DB/file
to read the norminal values (same for phase, beta, dispersion, tune).
One excepation is @code{getTune( )}, which is a readout of online tune
measurement. 

@strong{To be discussed}: How to store simulation data?

@end deftypefun

@deftypefun {status =} savePhase( @var{mode}, @var{phase}, @var{info} )

Save phase advance to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: phase - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveBeta ( @var{mode}, @var{beta}, @var{info} )

Save beta to database. Data is permanent across reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: beta - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveDispersion ( @var{mode}, @var{disp}, @var{info} )

Save dispersion to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: disp - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveTune ( @var{mode}, @var{tune}, @var{info} )

Save phase advance to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: tune - numeric (double) [nux, nuy].
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {} saveTuneRm ( @var{mode}, @var{rm}, @var{info} )

Save tune response matrix to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: rm - numeric 2-d array (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description (@pxref{Data
Management}: Tune correction matrix).
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveChrom ( @var{mode}, @var{chrom}, @var{info} )

Save chromaticity to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: tune - numeric (double) [chromx, chromy].
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {} saveChromRm ( @var{mode}, @var{rm}, @var{info} )

Save chromaticity response matrix to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: rm - numeric 2-d array (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description (@pxref{Data
Management}: Chromaticity correction matrix).
@item return: status
@item unit: [TBD].
@end enumerate

@end deftypefun


@deftypefun {chmRm =} getChromRm ( @var{mode} )

Get the stored response matrix(Jacobian) of chromaticity, it is with
respect to sextupoles in dispersive region.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: chmRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Chromaticity correction matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {chmRmInfo =} getChromRmInfo ( @var{mode} )

Give full information, such as timestamp, tune, ..., related to
chromaticity response matrix from database.  

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: chmRmInfo - subset data structure of (@pxref{Data
Management}: Chromaticity correction matrix).  
@item unit: [TBD].
@end enumerate

@deftypefunx {nuRm =} getTuneRm ( @var{mode} )

Get tune response matrix from database with respect to (two) quadrupoles.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: nuRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Tune correction matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {nuRmInfo =} getTuneRmInfo ( @var{mode} )

Give all details about when and how the tune response matrix was
measured from database. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: nuRmInfo - subset data structure of (@pxref{Data
Management}: Tune correction matrix).  
@item unit: [TBD].
@end enumerate
@end deftypefun

 
@deftypefun {[[elems], [s]] =} getNeighbors ( @var{element}, @var{group}, @var{n} )

Get a list of @math{n} elements belongs to @var{group}. The list is
sorted along @math{s} (the beam direction).

@code{getNearbyBpm} are built upon this routine, and it returns nearby
BPMs for magnets

Data structure:
@enumerate
@item params: element - string; element physics name.
@item params: group - string; group name.
@item params: n - numeric (integer); number of elements nearby. Total
elements will be @math{2*n + 1}
@item return: a 2-d array. [elems] contains all element physics name,
and [s] contains all element @math{s} location.
@end enumerate

@end deftypefun

@deftypefun {stepsize =} getStepsize ( @var{element} )
Get stepsize for scanning an element. This information is described (@pxref{Data
Management}: Step size).

Data structure:
@enumerate
@item params: element - string; element physics name.
@item return: stepsize - numeric (double). 0 if an element does not
have this property.
@end enumerate

@end deftypefun

@deftypefun {} convertUnit ( )

Converts between physics and engineering units. (@strong{Needs more information})

Input/output data flow needs to be clarified.

@end deftypefun



@strong{Who can explain the following API and give input/output for
them, choi???}

@deftypefun {[???] =} getGroundLevel(???)

(Choi, ???)

This API is only available in case devices monitoring the level of
ground and/or girder are installed. It returns the reading
values. These values can be used to calibrate the BPM readings.

Data structure:
@enumerate
@item params: ???
@item return: ???
@end enumerate

@deftypefunx {[???] =} getChamberOffset(???)

(Choi, ???)

This API is only available in case devices monitoring the vacuum
chamber offset are installed. It returns the reading values. These
values can be used to calibrate the BPM readings.

Data structure:
@enumerate
@item params: ???
@item return: ???
@end enumerate

@end deftypefun

@deftypefun {} setCurrentDependency ( )

(Choi, ???)

@deftypefunx {} calibrate ( ) 

(Choi, ???)

@deftypefunx {} getVibrationFrequency ( )

(Choi, ???)

@deftypefunx {} getVibrationSource ( )

(Choi, ???)

@deftypefunx {} Bpm2PbpmReading ( )

(Choi, ???)

@end deftypefun

@end table

@node Orbit Control and Analysis
@section Orbit Control and Analysis

This chapter focus on orbit related functions. 

@enumerate
@item Obtain static orbit: @code{getOrbit}, @code{getOrbitX}, @code{getOrbitY}, @code{getOrbitDrift}, 
@item Get turn-by-turn orbit: @code{getTbtOrbit}
@item Orbit correct: @code{correctOrbit}
@end enumerate

The APIs should be able to deal with dead BPM automatically (need set
up a convention). 

@node Orbit Control and Analysis API
@section Orbit Control and Analysis API

@table @code
@deftypefun {(orbit, ts, status) =} getOrbit ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbit

This function returns an array of both horizontal and vertical orbit
at BPMs specified by input @var{sequence} and @var{group}. The
@var{sequence} can be an array of index (1d ? or 2d ?). @var{group} is
a preconfigured string in global property, e.g. ``FOFB'' can be used
for BPMs in fast orbit feedback systems. These orbits are with respect
to golden orbit. 

Use @code{getMembers} to find out locations of the orbit.

Requirement: 
@enumerate
@item @code{getOrbit()}, get orbit at all BPMs;
@item @code{getOrbit("*C01")}, get orbit of BPMs whoes name matches (one "*C01";
@item @code{getOrbit([[1,1], [2,3]])}, get orbit at the 1st BPM in cell 1, 3rd BPM in cell 2; 
@item @code{getOrbit(2,3)} (? 3rd in cell 2 ?) 
@item sychronized to same turn if required. 
@end enumerate

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (2-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate


@deftypefunx {(orbit, ts, status) =} getOrbitX ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbitX

@code{getOrbitX}, returns horizontal orbit. It can be any combination
of single BPM, all in one cell, or whole facility.

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (1-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate

@deftypefunx {(orbit, ts, status) =} getOrbitY ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbitY

@code{getOrbitY}, returns vertical orbit. It can be any combination of
single BPM, all in one cell, or whole facility.

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (1-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate

@end deftypefun

@deftypefun {(orbit, ts) =} getTbtOrbit ( @var{sequence},  @var{group}, @var{turn})
@code{getTbtOrbit} returns the TBT(turn by turn) orbit from specified
BPMs, each has @var{turn} turns. 

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name, the BPMs in this group have
to have the TBT capability.
@item params: turn - integer; number of how many turn to fetch.
@item return: orbit - numeric (double) array; TBT orbit;

ts - time stamp (array);

@item unit: [TBD].
@end enumerate

@end deftypefun


@strong{The definition of three APIs, @code{getOrbitSnapshot},
@code{getOrbitSnapshotX}, @code{getOrbitSnapshotY}, are not
clear. shot only, no average, what does this stand for? How about
synchronized to same turn? in this API or a new one?}

@deftypefun {orbit =} getOrbitSnapshot ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics). 

@deftypefunx {orbit =} getOrbitSnapshotX ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics).

@deftypefunx {orbit =} getOrbitSnapshotY ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics).

@end deftypefun


@deftypefun {status =} setBpmReference ( @var{group}, @var{ref} )
@code{setBpmReference}, Same as setGoldenOrbit, but only for one
specific BPM. 

@strong{DANGEROUS}: This setting is only valid for one session, not
saved for future Golden orbit(next ramp/injection/run)
                                                                                              
Requirement: May not be able to implemented for other applications using
this information: if I set in one application, is it able to be
reflected in orbit feedback ?  Yes ? no ? or do I really want to?

Data structure:
@enumerate
@item params: group - string; group name.
@item params: ref - numeric (double) array; reference value for each BPM
@item return: status 
@item unit: [TBD].
@end enumerate

@end deftypefun

@deftypefun {orbit =} getGoldenOrbit ( @var{mode} )

@code{getGoldenOrbit} returns the golden orbit for specified operation
mode. This golden orbit is used for online.

Data structure:
@enumerate
@item params: mode - string; mode name. online golden value if empty
@item return: orbit - numeric (double) array (2-d)
@item unit: [TBD].
@end enumerate

@deftypefunx {orbit =} loadGoldenOrbit ( @var{mode}, @var{source="golden_orbit.txt"} )
@code{loadGoldenOrbit} returns the golden orbit for specified
operation mode from a file or database, which is the norminal one. 
We can temporary change golden orbit of online mode, but keep
database untouched, and use @code{loadGoldenOrbit} to reset to the
default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; mode name. Default golden value if empty.
@item params: source - TBD; where to load from, file or database.
@item return: orbit - numeric (double) array (2-d)
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} setGoldenOrbit ( @var{mode}, @var{orbit} )
@code{setGoldenOrbit} sets golden orbit for specified operation mode,
with given @var{orbit}. 

Data structure:
@enumerate
@item params: mode - string; mode name. Current machine mode if empty.
@item params: orbit - numeric array (2-d);
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveGoldenOrbit ( @var{mode}, @var{orbit}, @var{destination="golden_orbit.txt"} )
@code{saveGoldenOrbit} save @var{orbit} to specified @var{destination}.

Data structure:
@enumerate
@item params: mode - string; mode name. Current machine mode if empty.
@item params: orbit - numeric array (2-d);
@item params: destination - TBD; where to store, a file or database.
@item return: status
@item unit: [TBD].
@end enumerate

@c These APIs working on golden orbits, returns the golden orbit for specified
@c operation mode, from a file or database, which is the norminal one. 
@c We can temporary change golden orbit of online mode, but keep
@c database untouched, and use @code{loadGoldenOrbit} to reset to the
@c default one for the current operation mode. Save will take online golden
@c orbit to a file or database.
@end deftypefun

@deftypefun {orbitRm =} getOrbitRm ( @var{mode}, @var{corrector}, @var{bpm} )

Get orbit response matrix from database with given @var{corrector} and
@var{bpm}.

Data structure:
@enumerate
@item params: mode - string; Mode name. Current machine mode by default.
@item params: corrector - string array; list of corrector physics/channel name.
@item params: bpm - string array; list of bpm physics/channel name.
@item return: orbitRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Orbit response matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {orbitRmInfo =} getOrbitRmInfo ( @var{mode} )
Give all details about when and how the orbit response matrix was
measured from database with given @var{mode}. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: orbitRmInfo - subset data structure of (@pxref{Data
Management}: Orbit response matrix).  
@item unit: [TBD].
@end enumerate

@deftypefunx {orbitRm =} loadOrbitRm ( @var{mode}, @var{source} )

@code{loadOrbitRm} returns the orbit response matrix for specified
operation mode from a file or database. Use @code{loadGoldenOrbit} to
reset to the default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: source - TBD; where to load from.
@item return: orbit response matrix; 
@item unit: [TBD].
@end enumerate


@deftypefunx {status =} setOrbitRm ( @var{mode}, @var{corrector}, @var{bpm} )

@code{loadOrbitRm} returns the orbit response matrix for specified
operation mode from a file or database. Use @code{loadGoldenOrbit} to
reset to the default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: corrector - string array; list of corrector physics/channel name.
@item params: bpm - string array; list of bpm physics/channel name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveOrbitRm ( @var{mode}, @var{destination}, @var{info} )

@code{saveOrbitRm} save orbit response matrix to specified @var{destinatoin}.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: destination - TBD; where to save
@item params: info - ;.
@item return: status
@item unit: [TBD].
@end enumerate


@c @code{getOrbitRm} get the orbit response matrix. Requirement: 1. Read
@c the configuration DB to get this RM.  @code{saveOrbitRM}
@c (@code{setOrbitRm}) save the measured Orbit RM. @strong{NOTE}: the column and row
@c are related to the list of correctors and BPMs, they might be changing
@c from time to time, we keep track of the correctors and BPMs using @var{info}

@end deftypefun


@deftypefun {bpm =} getLiveBpm ( )

@code{getLiveBpm} get a list of all live BPM.

Data structure:
@enumerate
@item return: bpm - string array; a list of bpm physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {bpm =} getDeadBpm ( )

@code{getDeadBpm} get a list of all dead BPM. Those bpm are removed
are not included.

Data structure:
@enumerate
@item return: bpm - string array; a list of bpm physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} disableBpm ( @var{group} )

@code{disableBpm} disable all bpm(s) belong to certain @var{group}.
A single bpm can be disabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} enableBpm ( @var{group} )

@code{enableBpm} enable all bpm(s) belong to certain @var{group}.
A single bpm can enabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveBpmStatus ( @var{group}, @var{status} )

@code{saveBpmStatus} save status of bpm(s) belong to certain @var{group}.

Data structure:
@enumerate
@item params: group - string; group name.
@item params: status - boolean; bpm boolean status.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {cor =} getLiveCorrector ( )

@code{getLiveCorrector} get a list of all live corrector.

Data structure:
@enumerate
@item return: cor - string array; a list of corrector physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {cor =} getDeadCorrector ( )

@code{getDeadCorrector} get a list of all dead corrector.

Data structure:
@enumerate
@item return: cor - string array; a list of corrector physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} disableCorrector ( @var{group} )

@code{disableCorrector} disable corrector(s) belong to certain @var{group}.
A single corrector can be disabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} enableCorrector ( @var{group} )

@code{enableCorrector} enable corrector(s) belong to certain @var{group}.
A single corrector can be enabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveCorrectorStatus ( @var{group}, @var{status} )

@code{saveCorrectorStatus} save status of corrector(s) belong to certain @var{group}.

Data structure:
@enumerate
@item params: group - string; group name.
@item params: status - boolean; bpm boolean status.
@item return: status
@item unit: [TBD].
@end enumerate

@end deftypefun

@strong{NOTE: Operates on status of BPMs and correctors. enable/disable will not
operate on DB, but @code{save*Status} will mark the dead elements and
take effect across restart.}

@end table

@c -----------------------------------------------------------------------------

@node Diagnostics
@section Diagnostics

@node Diagnostics API
@section Diagnostics API

@strong{This part need more discussion with diagnostics group}

@table @code
@deftypefun {freq =} getRfFrequency ( )
@deftypefunx {h =} getRfHarmonic ( )
@deftypefunx {v =} getRfVoltage ( )
@deftypefunx {phi =} getRfPhase ( )
Retrieve RF information, frequency, harmonic number, voltage, phase ?
@end deftypefun


@deftypefun {min, max =} getPsLimit ( )
Returns lower and upper limits of one power supply (or channel of a magnet ?)
@end deftypefun

@deftypefn {Ext} {major, minor, patch =} version ()
Return version number
@end deftypefn

@deftypefn {Ext} {} whatsup ()
@deftypefnx {Ext} {} howudoing ()
What's up ! How U Doing ! Try this command within 10 seconds you got a
control terminal. Our HLA will tell you what is going on there. The
output is not always the same.
@end deftypefn 


@deftypefun {var =} getChannelVariance ( @var{period} )
@deftypefunx {min,max =} getChannelRange ( @var{channel} )
@deftypefunx {min,max =} getChannelBoundary ( @var{channel} )

@end deftypefun


@deftypefun {current =} getBeamCurrent ( )
@deftypefunx {lifetime =} getBeamLifetime ( )
@deftypefunx {sigmax, sigmay =} getBeamSize ( )
@deftypefunx {} getBeamProfile ( )
Returns beam current, lifetime, size. The profile can be an image (can we do it in EPICS ?)
@end deftypefun

@deftypefun {pres =} getPressure ( @var{loc} )
Vacuum information along the ring (or at specific location ?).
@end deftypefun

@deftypefun {min, max, avg, var =} measSetGetAgreement ( @var{channel}, @var{min}, @var{max}, @var{n} )
Randomly set @math{n} values between @var{min} and @var{max}, check statistics of @math{Rb-Sp}, i.e. the difference of readback and setpoint.
@end deftypefun

@deftypefun {loss =} getLossAt ( @var{loc} )
(Choi, ???) beam loss monitor system
@end deftypefun

@end table


@node Direct Channel Access
@section Direct Channel Access,

In this part, the API talks with real EPICS channels in case we need low
level access. These API can be used for interactive environment to
increase the ability of control. They are also useful in general
plotting/monitoring specified channels when usually the GUI application
was not designed for.

@table @code
@deftypefun {val =} getAm ( @var{am} )
@deftypefunx {val =} getSp ( @var{channel} )
@deftypefunx {val =} setSp ( @var{channel}, @var{value} )
@end deftypefun


@deftypefun {} stepSp ( @var{channel}, @var{low}, @var{high}, @var{n} )
@deftypefunx {} stepSp ( @var{channel}, @var{n} )
change by a small amount. This amount could be different for different
channel/element.  A method setStepSize for a channel may be needed.
@end deftypefun

@deftypefun {channels =} getChannels ( @var{element} )
given an element, return all the channel names this element has (confusing with @code{getPv}?)
@end deftypefun

@deftypefun {element =} getChannelOwner ( @var{channel} )
input a channel, return the element name it belongs to. (not a good name ?)
@end deftypefun

@deftypefun {avg, var =} measChannelResponse ( @var{channel}, @var{n} )
Measure how fast set/get response, try @math{n} times, return average and variation in unit of @emph{seconds}
@end deftypefun

@deftypefun {} inChannelLimits ( @var{channel}, @var{setpoint} )
Check whether this setpoint is within the limits.
@end deftypefun

@deftypefun {} getChannelLabel ( @var{channel} )
Get the label for specific channel when do plotting.
@end deftypefun

@end table


@c -----------------------------------------------------------------------------

@node Extended CAPI
@chapter Extended CAPI

These APIs are not using service directly, but composed of fundamental CAPIs introduced before.

@table @code

@deftypefn {Ext} {} getNearbyBpm ( @var{group} )
return two BPMs bound each element in this group
@end deftypefn

@deftypefn {Ext} {} measBeamLifetime ( @var{delay}, @var{npoints}, @var{order} )
Instead of @code{getBeamLifetime} which runs continuously, this routine
get the current and analyze lifetime by fitting a polynomial of certain
order.
@end deftypefn

@deftypefn {Ext} {} measOrbitRm ( ) 
@code{measOrbitRm} set orbit corrector, measure colosed orbit shift.
Requirement: 1. get the list of correctors, in the "orbit correction"
group, from configuration DB; 2. get the list of BPMs, in the "orbit
correction"; 3. set one corrector, get orbit at thoese BPMs;
@end deftypefn

@deftypefn {Ext} {} getTrimQuad ( )
get trim quadrupoles used for tune correction, and their strength ?
Requirement: Read the configuration DB. get the magnet in a certain
"group" or "group name"
@end deftypefn

@deftypefn {Ext} {} measChromaticity ( )
@code{measChromaticity} Measure the chromaticity of current lattice
Requirement: 1. Measure tunes; 2. set(step) RF frequency; 3.  store the
measured chromaticity, overwrite the old one or copy create to a new
one, and set the new one to be default(for this mode) 4. numerical
fitting (polynomial), linear and 2nd order
@end deftypefn

@deftypefn {Ext} {} measChromaticityRm ( )
@code{measChromaticityRm} Measure the RM of chromaticity for
chromaticity correction.  Requirement: 1. measure linear chromaticity;
2. change sextupole settings.
@end deftypefn

@deftypefn {Ext} {} correctChromaticity ( )
@code{correctChromaticity} It is called with desired chromaticity, and
uses chromaticity response matrix to correct the chromaticity and return
the final chromaticity, None if the job is not achieved.
                                                                                              
Requirement: 1. get stored chromaticity RM data. 2. change the sextupole
values (two values for H/V, 30 cells are identical)
@end deftypefn

@deftypefn {Ext} {} setLocalBump ( )
@code{setLocalBump} create a three kicker bump or four kicker local
bump. check the orbit against original state outside of the
bump. Requirement: 1. set 3 or 4 correctors; 2. get whole orbit; 3. get
the location of each corrector and BPMs, so filter the BPMs outside of
the bump.
@end deftypefn

@deftypefn {Ext} {} getBbaQuad ( )
@end deftypefn

@c @deftypefun {drift =} getOrbitDrift ( @var{sequence}, @var{group}, @var{delay})
@deftypefn {Ext} {min,max =} getOrbitDrift ( @var{sequence}, @var{group}, @var{delay} )
@deftypefnx {Ext} {var =} getOrbitVariance ( @var{sequence}, @var{group}, @var{delay} )
@tpindex getOrbitDrift
This returns the orbit drift after @var{delay} seconds.
@end deftypefn
@c end deftypefun

@deftypefn {Ext} {} measTune ( @var{bpm} )
@deftypefnx {Ext} {} measBeta ( )
@deftypefnx {Ext} {} measPhase ( )
@deftypefnx {Ext} {} measDispersion ( )
@code{measTune} uses turn by turn BPM data to get tune
@end deftypefn


@deftypefn {Ext} {} measTuneRm ( @var{trimx}, @var{trimy} )
@end deftypefn

@deftypefn {Ext} {} getTrimQuad ( )
@end deftypefn

@deftypefn {Ext} {orbit =} correctOrbit ( @var{corrector}, @var{bpm}, @var{iter} )
@deftypefnx {Ext} {orbit =} correctOrbitX ( @var{corrector}, @var{bpm}, @var{iter} )
@deftypefnx {Ext} {orbit =} correctOrbitY ( @var{corrector}, @var{bpm}, @var{iter} )
This function do the orbit correction using default measured orbit response matrix
@end deftypefn

@deftypefn {Ext} {} setCoupling ( @var{couple} )
@end deftypefn

@deftypefn {Ext} {} calcCoupling
@end deftypefn

@deftypefn {Ext} {} getBpmVariance ( @var{period} )
@code{getBpmVariance} monitor the variance of BPM reading. Same
signature as getOrbit/getOrbitX/getOrbitY, monitor the beam statistics
for a certain time @var{period}. 1sec ? 10 sec ?  From current state or from a given
reference values.
                                                                                              
Requirement: read BPM orbit, can call getOrbit, getOrbitX, getOrbitY
@end deftypefn

@deftypefn {Ext} {} calcTbtOrbitPhase ( )
@end deftypefn

@deftypefn {Ext} {der =} measChannelDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
@deftypefnx {Ext} {der =} measChannelForwardDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
@deftypefnx {Ext} {der =} measChannelBackwardDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
Measure the derivatie of @var{channel_read} with respect to @var{channel_set} by midpoint finite difference method. The step size is @var{stepsize}. Forward and backward derivative can also be implemented.
@end deftypefn

@end table


@node Server APIs (SAPI)
@chapter Server APIs (SAPI)

@node Overview
@section overview
In brief, the server APIs do to things, query the lattice settings, and do the settings. 

For example, a HLA wants to do *getOrbit("P\*G2C0?")* (get BPM at girder
2, cell [1,2,3,4,5,6,7,8,9]), the server should be able do two thing:

@enumerate
@item tell what are these elements: (PH1G2C01A, PH2G2C01A, PM1G4C01A,PM1G4C01B, ...)
@item get the orbit of these elements(BPMs), if there is a requirement on the timestamp, apply it. 
@end enumerate

The overview requirementfor SAPI

@itemize 
@item *Lattice Manager*, it manages a lattice as a configure for every HLA, here the manage means: read, set, change these information. 
      @itemize @minus
      @item physics name(unique), logic name(group) of each element.
      @item location (or sequence? we can get this from its location).
      @item channels for setting and reading
      @item limits of each channel
      @item unit convertion infomation (from engineering, e.g. current, to physics value)
      @item risk level (?? warning or not if applications try to set this channel)
      @item ramp speed
      @item step size of setting it
      @item delay for each step when do continues ramping (?? needed or not ??)
      @item used for specified purpose ? (this can be organized as group, quadrupoles used for beam based alignment can be in "BBA" group)
      @item nominal setting (operation lattice)
      @item set point for various set purpose ( for example low alpha lattice, this quadrupole will have different strength. operation lattice is one instance of these set)
      @item query groups it belongs to, how many set of values it can be.
      @item data archiever info, location, frequency, (we can get the history from it)
      @item realtime status? disabled or enabled ? especially for BPM and corrector ?
      @item golden orbit, read/write
      @end itemize
@item I/O, if SAPI has storage integrated, we can use it as a config for I/O
      @itemize @minus
      @item default location for storage
      @end itemize
@item Next block is doing the set/read. After get the information from lattice manager, then we should know how to set the magnet via a server(I here call it a gateway)
      @itemize @minus
      @item call this gateway with an abstract name ? or a channel ? or a list of channels ?
      @item consider the timestamp synchronization ? time out ?
      @item get the value only when the variance of this channel or the other channel is below some threshold ?
      @item get a value in the future, (wait 20ms) ?
      @item get values in a specific time range ? e.g. in the next 10 sec.
      @end itemize
@end itemize

@node Data storage API
@section Data storage API

The strategy for data storage is based on the server adopted for
NSLS-II project. For example, the data archiving system, and or
machine status snapshot so-call logscore system. The API described
here is for a data server to retrieve from data archiving system for
example to provide them to client in a pre-defined structure.

@node Data archiving API
@subsection Data archiving API
Coming soon.

@node Logscore API
@subsection Logscore API
Coming soon.



@node Reference
@unnumbered Reference

@itemize @asis
@enumerate
@item J. Bengtsson, B. Dalesio, T. Shaftan, T. Tanabe, @cite{NSLS-II:
Model Based Control - A Use Case Approach}, Tech-note 51, Oct 2008 

@item F. Willeke, @cite{Assumptions on NSLS-II Accelerator Commissioning}, November 22, 2009

@item F. Willeke, @cite{The Path to Accelerator Commissioning}, talk
on ASD Project Meeting, Jan 2010

@item S. Krinsky, @cite{NSLS-II Storage Ring Commissioning}, NSLS-II ASD Retreat, May 13, 2010.

@item @cite{National Synchrotron Light Source II - Nomenclature Standard},
LT-ENG-RSI-STD-002, Jan 21, 2009, Rev 2

@item @cite{National Synchrotron Light Source II - Accelerator Systems
Requirements Document, Storage Ring Physics Nomenclature Standard},
RSI Document 1.3.4-001, Feb 17, 2008, Rev 1
@end enumerate

@end itemize

@iftex
@normalbottom
@end iftex

@node Index
@unnumbered Index

@printindex cp

@node Function Index, Variable Index
@unnumbered Function Index

@printindex fn



@node Notes
@unnumbered Note

@enumerate
@item How long to fix (or by pass) an unpredicted situation(or more worse, a bug?) in control room, in a two hours shift ?
@item Server side log ?
@item How to keep the server(manager) most updated
@end enumerate

@node Coding Style
@heading Coding Style

@enumerate
@item Use @code{doxygen} for @code{C/C++} ?
@item write @code{__doc__} in Python ?
@item Use @code{sphinx} for Python ?
@item 4 spaces per indentation level.
@item never mix tabs and spaces. Use space to replace tab
@item limit all lines to a maximum of 79 characters.
@item document well and in detail.
@end enumerate

@node Summary of Meetings
@heading Summary of Meetings
@c unnumbered Summary of Meetings

@enumerate
@item @strong{2010/04/23, Bob, Choi, Don, Guobao and Lingyun}
      @itemize @minus
      @item Guobao showed implementations of two server, a use case of global
     orbit is presented. Exposed some details to us, and helpful to
     implement a CAPI, and a guide for defining the SAPI.
     @item Should we have a server side log ? like Apache log in linux ?
   @item We should be able to define "a set of magnets" and save it, leave
     comments and username. So in the future, we can recall this set, and monitor the data
   @item We will have a more detailed description of CAPI, for Guobao and Don
     to define the SAPI.
   @item We will have an example of "creating local orbit bump" based on this
     architecture, and show them in AP group, and have more discussions.
   @item On the server side, we agreed to have more discussions on what kind of functions can be provided to CAPI, and how to use them. Take the "creating local orbit bump" as an example to move toward the CAPI requirement. After several discussions, two groups from two sides can merge together with a complete set of CAPI/SAPI.
@end itemize
@end enumerate

@node Tools/Coding/Documentation
@heading Tools/Coding/Documentation

@itemize
@item C/C++ and Python would be the main language for HLAs development and data process.
@item Python_ + iPython_ + matplotlib_ + numpy_ are preferred for
   *Interactive Environment*. For people who prefer MATLAB, we also provide MATLAB Middle Layer Toolkit (MMLT) by Greg Portman at Lawrence Berkeley National Laboratory as an option.
@item The HLAs can be written in Python, in this case we prefer PyQt as GUI
   library. This makes the sharing of API between interactive environment
   and HLAs easy. However, we can also use C bindings of EPICS, then
   Qt/C++ as GUI library. For applications use only low level API
   (operates on channels directly) this can also be a recommended choice.
 @item Other monitoring applications can be constructed from MEDM or CSS.
 @item A central repository will be set up, and code review (or other form of
   discussion the code we have written) will also be arranged.
 @item A running virtual accelerator is already running, and use for testing
   the HLAs.
@end itemize

@node Links
@heading Links

@itemize
@item @uref{http://www.python.org/, Python.org}
@item @uref{http://ipython.scipy.org/moin/, iPython}
@item @uref{http://matplotlib.sourceforge.net/, matploblib}
@item @uref{http://numpy.scipy.org/}
@end itemize


@c @node Appendix
@c chapter Appendix

@node Revision History
@heading Revision History

@itemize @bullet
@item 2010-06-08, Lingyun Yang, init
@item 2010-06-14, Guobao Shen, rev 1
@end itemize


@bye
